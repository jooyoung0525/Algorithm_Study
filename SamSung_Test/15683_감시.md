### 배열..복사 어렵....
### 남의 풀이 보고 공부... 어려워...ㅓ푼사람똑똑해....하....(아직 이해 살짝안감..)

-------------------------------------------------------------------------------------------------------------------------

![qwer](https://user-images.githubusercontent.com/29946480/66384307-82142e80-e9f9-11e9-875c-f42575a14a4e.JPG)
![erqer](https://user-images.githubusercontent.com/29946480/66384305-817b9800-e9f9-11e9-875e-a3312e34cb10.JPG)
![qwerqwer](https://user-images.githubusercontent.com/29946480/66384308-82142e80-e9f9-11e9-8d57-a6a952cb746a.JPG)
![qweqwerqwer](https://user-images.githubusercontent.com/29946480/66384306-817b9800-e9f9-11e9-8e2e-a11090b3a1bd.JPG)

--------------------------------------------------------------------------------------------------------------------------
## 풀이 1.(구조체 배열만들어서 풀기)

```c
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int N, M;
int map[10][10] = { 0 };
struct cctvinfo { int x, y, num; };
cctvinfo cctv[8];
int rotation[] = { 0,4,2,4,4,1 };
int cctv_size = 0;
vector<int>V;

void dir(int d, cctvinfo cctv);
void DFS(int cnt);
void arr_copy(int origin[10][10], int copyy[10][10]);

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);


	cin >> N >> M;
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			cin >> map[i][j];
			if (map[i][j] > 0 && map[i][j] < 6)
			{
				cctv[cctv_size] = { i,j,map[i][j] };
				cctv_size++;
			}
		}
	}

	DFS(0);

	int mm = *min_element(V.begin(), V.end());

	cout << mm;

	system("pause");
	return 0;
}


void dir(int d, cctvinfo cctv)
{
	d %= 4;
	if (d == 0)
	{
		for (int i = cctv.x - 1; i >= 0; i--)
		{
			if (map[i][cctv.y] == 6) break;
			map[i][cctv.y] = -1;
			
		}
	}
	else if (d == 1)
	{
		for (int i = cctv.y + 1; i < M; i++)
		{
			if (map[cctv.x][i] == 6)break;
			map[cctv.x][i] = -1;
		
		}
	}
	else if (d == 2)
	{
		for (int i = cctv.x + 1; i < N; i++)
		{
			if (map[i][cctv.y] == 6)break;
			map[i][cctv.y] = -1;
			
		}
	}
	else if (d == 3)
	{
		for (int i = cctv.y - 1; i >= 0; i--)
		{
			if (map[cctv.x][i] == 6) break;
			map[cctv.x][i] = -1;
			
		}
	}
}

void DFS(int idx)
{
	int copy_map[10][10];

	if (idx == cctv_size)
	{
		int result = 0;
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				if (map[i][j] == 0)
					result++;
			}
		}
		V.push_back(result);
		
		return;
	}

	int cc_num = cctv[idx].num;
	for (int i = 0; i < rotation[cc_num]; i++)
	{
		arr_copy(copy_map, map);

		if (cc_num == 1)
		{
			dir(i, cctv[idx]);
		}
		else if (cc_num == 2)
		{
			dir(i, cctv[idx]);
			dir(i+2, cctv[idx]);
		}
		else if (cc_num == 3)
		{
			dir(i, cctv[idx]);
			dir(i+1, cctv[idx]);
		}
		else if (cc_num == 4)
		{
			dir(i , cctv[idx]);
			dir(i+1, cctv[idx]);
			dir(i + 2, cctv[idx]);
		}
		else if (cc_num == 5)
		{
			dir(i, cctv[idx]);
			dir(i+1, cctv[idx]);
			dir(i+2, cctv[idx]);
			dir(i+3, cctv[idx]);
		}
		DFS(idx + 1);
		arr_copy(map, copy_map);
	}


}

void arr_copy(int origin[10][10], int copyy[10][10])
{
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			origin[i][j] = copyy[i][j];
		}
	}
}

```
