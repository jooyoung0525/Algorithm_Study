# 해시(Hashing)

- C++ 에서 표준STL인 unordered_map이용 // using namespace std;에 있음

- unordered_map은 map과 달리 정렬을 안해도 됨 (기본적으로 정렬를 해줌)




### EX) unordered_map<string,int> M; ==> key가 string이고, value가 int인 해시테이블 생성.  
### *( 이 그림은 아래의 코드이해하는데 도움 )*

<img width="281" alt="해시" src="https://user-images.githubusercontent.com/29946480/69848991-e5fef900-12be-11ea-8943-8d7cf41eb529.PNG">


--------------------------------------------------------------------------------------------------------------------------

### 문제링크

    https://programmers.co.kr/learn/courses/30/lessons/42576

--------------------------------------------------------------------------------------------------------------------------

### 정렬이용 (첫 풀이)
```c
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    string answer = "";
    
    sort(participant.begin(), participant.end());
    sort(completion.begin(), completion.end());
    
    for(int i=0;i<completion.size();i++)
    {
        if(participant[i] != completion[i])
            return participant[i];
    }
    
    return participant[participant.size() - 1];
}
```

-----------------------------------------------------------------------------------------------------------------------------

### 해시테이블 (completion기준)

```c
string solution(vector<string>participant, vector<string>completion)
{
	string answer = " ";
	unordered_map<string, int>M;

	for (auto person : completion) //completion의 벡터를 기준으로 unordered_map에 값을 삽입하는 코드
	{
		if (M.end() == M.find(person)) // map의 find(#)함수는 map에 #값이 없을 때, 가장 끝을 가르키는 iteratior값인 map.end() 반환
		                               // 결국 M에 person이라는 string값이 없으면 아래 코드 실행
		{
			M.insert(make_pair(person, 1));  //unordered_map에 person값이 없으면 person,1 삽입
			continue;
		}
		else                        
		{
			M[person]++;  //unordered_map에 person값을 찾았으면 해당key의 value값++
			continue;
		}
	}

	for (auto person : participant) //참가자를 완주한사람의 해시테이블과 한명씩 비교
	{
		if (M.end() == M.find(person))   //해당참가자가 완주한사람의 정보에 없으면 answer은 해당참가자가 됨.
		{
			answer = person;   
			break;
		}
		else
		{
			M[person]--;  //해당참가자가 완주한사람의 정보에 있으면 해당참가자의 value값--; 
			              // (value값이 음수면 같은이름인사람중 몇명이 완주를 못한 것)
			if (M[person] < 0)
			{
				answer = person;
				break;
			}
		}
	}

	return answer;
}

```
