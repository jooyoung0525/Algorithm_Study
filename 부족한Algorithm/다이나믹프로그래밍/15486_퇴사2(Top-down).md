### 아직 연습부족..

### 내가세운 점화식 최대수익인 memo[N] 구하는 문제

### 큰문제 -> 작은문제 : memo[N] = memo(N-T[N])+P[N]

==> 잘못생각한것 :: 다음날 상담했을때만 고려해줌, N이 상담마지막날인데 memo(N-T[N])+P[N]식에서 작은문제의 점화식을 세우지못하고 큰문제의 점화식을 세워버림

------------------------------------------------------------------------------------------------------------------------------

https://www.acmicpc.net/problem/15486

------------------------------------------------------------------------------------------------------------------------------

## 풀이 1 (메모이제이션 이용) ==> Top-down방식

```c
#include<iostream>
#include<algorithm>

using namespace std;

int N;
int T[1600000], P[1600000], memo[1600000] = { 0 };

int out(int day) //변수 1부터!!(작은문제부터)
{
	if (day == N + 1) return 0; //만약 퇴사날일때 상담하면 받는금액은 0(상담을 할 수 없으므로)
	if (day > N + 1) return -9999999; //퇴사날이 지나면 상담을 할 수 없으므로 가장 작은값으로 설정 
	if (memo[day] > 0) return memo[day]; //값이 메모되있으면 그 값을 리턴

	return memo[day] = max(out(day + 1), (out(day + T[day]) + P[day])); //N날의 최대수익은 (다음날 상담안했을때,상담했을때 둘중 큰값을 리턴)
                                                                       //다음날 상담을 할 수도 있고 안할수도 있기때문
	
}

int main()
{
	cin >> N;
	for (int i = 1; i <= N; i++)
	{
		cin >> T[i] >> P[i];
	}
	cout<<out(1); //첫날부터 시작
	return 0;
}


```
