# Flood fill

● 어떤 위치와 연결된 모든 위치를 찾는 알고리즘

--------------------------------------------------------------------------------------------------------------------
## 단지번호매기기랑 비슷한문제!
----------------------------------------------------------------------------------------------------------------------
![island](https://user-images.githubusercontent.com/29946480/62061420-6b966d80-b227-11e9-97c8-37b327e63045.PNG)
-----------------------------------------------------------------------------------------------------------------------
## DFS이용한 풀이

- 섬 사이를 걸어 갈 수 있으면 같은섬으로 count!
- 걸을 수 있는 섬의 조건 : 상하좌우대각선

---------------------------------------------------------------------------------------------------------------------
```c
#include<cstdio>
#include<cstdlib>


int dx[] = { -1,1,0,0,-1,-1,1,1 }; //상하좌우대각선 --> 다음위치
int dy[] = { 0,0,-1,1,1,-1,1,-1 }; //상하좌우대각선 --> 다음위치

void DFS(int x, int y, int w, int h,int map[52][52],int visit[52][52]) {

	visit[x][y] = 1;

	for (int i = 0; i < 8; i++)
	{
		int nx = x + dx[i];
		int ny = y + dy[i];

		if (nx > -1 || nx < w || ny > -1 || ny < h) {
			if (visit[nx][ny] == 0 && map[nx][ny] == 1)
			{
				DFS(nx, ny, w, h, map, visit); //범위를 벗어나지 않고, 방문한적이 없고, 다음위치에 섬이 있으면 DFS탐색
			}
		}
	}

}

int main()
{
	int w, h;
	while (scanf("%d %d", &w, &h) == 2 && w != 0 && h != 0) // 입력리턴값이 2개이고, w와 h가 0이 아니면 반복!!
	{
		int map[52][52] = { 0 }; //초기화를 반드시 해주어야함(입력하고 바로 출력이 되기때문)
		int visit[52][52] = { 0 }; //초기화를 반드시 해주어야함

		for (int i = 0; i < h; i++)
		{
			for (int j = 0; j < w; j++)
			{
				scanf("%d", &map[i][j]);
			}
		}
		
		
		int cnt = 0;
		for (int i = 0; i < h; i++)
		{
			for (int j = 0; j < w; j++)
			{
				
				if (map[i][j] == 1 && visit[i][j] == 0) {

					DFS(i, j, w, h,map,visit);
					cnt++; 
				}
			}
		}

/*
		for (int i = 0; i < h; i++)
		{
			for (int j = 0; j < w; j++)
			{
				printf("%d", visit[i][j]);
			}
			printf("\n");
		}

*/
		printf("%d\n", cnt);

	}
//	system("pause");
	return 0;
}
```
